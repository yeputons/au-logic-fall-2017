# Constraint handling rules (CHR)

Предпоследняя тема нашего курса.
Сначала нам даже тему не сказали, но вот задачи, которые надо написать руками:

1. Можем ходить по клетчатой плоскости в четыре стороны (EWNS).
   Нам дают последовательность действий, мы проходим из исходной
   точки в конечную. Надо вывести кратчайшую последовательность, которая
   точно так же доходит из исходной в конечную.
2. Есть монеты в 1, 2, 0.5, 0.2, 0.1 евро. Надо разменять сумму на
   минимальное количество монет.
3. Есть молекулы водорода (H_2) и кислорода (O_2) и правила:
   1Heat + H_2 + H_2 + O_2 = 2H_2O  // На самом деле взрывается, но пофиг
   1Electricity + 2H_2o = H_2 + H_2 + O_2
   Нам на вход дают некое количество единиц тепла, электричества и молекул
   трёх типов, надо просто выполнять реакции, пока можно, в конце вывести,
   что получилось.

CHR - это логический DSL, который можно реализовать в Java, в Haskell, ещё где-то.
Основной реципиент - Prolog. В частности, в SWI-Prolog есть.

В принципе CHR - это частный случай систем переписывания (rewriting systems),
которые, увы, нам не рассказали.

## Система переписывания
Пока что говорим про системы переписывания термов.
Тогда у нас есть термы (в общем случае - нечто, скажем, граф).
Ещё у нас есть сколько-то правил вида T_1 -> T_2 (в каждом могут быть переменные).
В простейшем случае у нас есть один терм (subject), мы перебираем
правила, матчим T_1 с S, если сматчилось - заменяем на T_2 с соответствующими переменными
(переменные в S, конечно, тоже могут быть, но они там ведут себя как нульарные функции).
Точно так же может быть больше одного subject и мы переписываем все вместе независимо.

Пример правила переписывания: f(X, Y) -> f(Y, X).

Это такая система, которая недетерминированно описывает преобразования.
Какие потенциально бывают свойства?
1. Терминируемость: не существует бесконечная последовательность переписываний.
   Обычно её нет без специальных усилий. Но можно доказать не в сильном, а в
   слабом смысле: множество возможных термов конечно.
2. Конфлюэнтность: если был терм S, мы его смогли независимо привести в A и в B,
   то обязательно можно найти терм S', в который переводятся A и B.
   
   
Если есть конфлюэнтность и строгая терминируемость, то система переписываний однозначна.
Если есть слабая терминируемость и конфлюентность, то система переписываний либо завершится
и выдаст единственную нормальную форму, либо будет работать бесконечно.

Одна из первых систем переписывания, по-видимому - лямбда-исчисление.

Есть специальные процедуры, которые умеют проверять, что системы конфлюентны (останавливаются,
если да, работают бесконечно, если нет).
Можно пробовать добавлять что-нибудь (хз что) в систему, чтобы она стала конфлюентной.

## Основные правила CHR
Для начала бывают constraint таких видов:
1. Интерпретируемые встроенные (builtin) ограничения: например,
   неравенства целых чисел или что-то такое.
2. Остальные ограничения, задаются семантикой CHR. Но выглядят
   точно так же, как builtin: просто атомарная формула (функция от чего-то).
   Всегда есть как минимум два ограничения: true, false.

Ещё можно добавлять свои ограничения двух видов (на самом деле трёх, но пока забьём):
1. Simplification (упрощение:):
   [<имя>@] H <=> C | B
2. Propagation (упрощение:):
   [<имя>@] H ==> C | B
   
Тут есть:
* H - head (голова), мультимножество пользовательских constraint'ов
* C - head (голова), мультимножество встроенных constraint'ов
* B - head (голова), мультимножество произвольных constraint'ов

Ещё исходно есть мультимножество Goal, в нём лежат constraint'ы.
Мы начинаем его переписывать (порядок применения не определён), пока
либо не получим неподвижную точку, либо не получим в нём false.

Как переписываются simplification: матчим то, что в H, с нашим Goal.
Если сматчисло - то проверяем, что C выполняются в контексте предположений из Goal.
Если выполняются - то выбрасываем из Goal то, что было в H, добавляем B.
В C, B могут быть связанные с H переменные.

Можно ещё добавить правило simpagation, которое выкидывает только часть из H:
  [<имя>@] H \ H1 <=> C | B
Но оно заменяется на simplification + propagation, поэтому нас не интересует.
В реализациях полезно, не более того.

## Семантика CHR

Пусть у нас был goal S_1, он переходит в S_2, если:
1. Правило `H <=> C | B`. Переименуем переменные в нём так, чтобы они не пересекались с S_1.
   Тогда если есть такой H' \subseteq S_1, то есть подстановка переменных \sigma,
   что H_{\sigma} = H', а CT |= S_1 => C_{\sigma} (т.е. в контексте S_1 по правилам
   интерпретируемых встроенных constraint'ов верно C с подставленными \sigma),
   то S_2 = S_1 \ H' \cup B_{\sigma}
2. Аналогично для `H ==> C | B`, только S_2  = S_1 \cup B_{\sigma}.

## Логическая семантика CHR

Программа может быть в каком-то смысле (вроде даже не очень творческом, но как хз)
представлена как конъюнкция следующих выражений для правил:
1. `H <=> C | B` заменяется на `\forall (C => (H <=> \exists y B(y)))`.
   Мы говорим, что для всех возможных подстановок переменных в C есть равнозначность
   между H с этими переменными и B (но в B могут возникнуть новые переменные).
2. `H ==> C | B` заменяется на `\forall (C => (H => \exists y B(y)))`
