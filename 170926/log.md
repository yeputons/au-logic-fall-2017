26.09.2017

# Преобразования в КНФ
Способ Цейтина (с новыми вершинами) против "наивного" метода.
Способ Цейтина почти всегда работает лучше, кроме очень маленьких формул. Например, в формуле (a && b) || c лучше раскрыть наивно, а не Цейтином.

# DPLL
DPP плохо годится, чтобы получить выполняющий набор -- он умеет лишь получать логические следствия.
Метод резолюций является refutation complete: "если исходная формула противоречива, то противоречие мы точно получим".

DPLL - это алгоритм, который позволяет найти выполняющий набор. Он не на методе резолюций, это просто dfs (backtracking).
Сначала заводим формулу в КФН: \Phi = \phi_1 \land \phi_2 \land \dots \phi_n.
Далее делаем преобразования:
1. Убрали одинаковые литералы в каждом клозе КНФ (очевидно).
2. Убрали клозы с A \lor \not A (очевидно).
3. Если переменная входит с одним знаком, то можно выкинуть все такие клозы.
4. Unit propagation: клоз из одного литерала {A} --- сразу поняли значение переменной, подставили в остальные клозы (каждый клоз либо уменьшился, либо удалился). 
4. Если ничего не помогло, пробуем зафиксировать значение какой-то переменной.
По сути просто перебор всех значений с доп.шагами 1-4. Оказывается, что они очень круты и позволяют сильно сократить дерево перебора. Шаги 1-2 можно сделать только в самом начале, поэтому основную работу делают шаги 3-4.

Дополнительные улучшения:
а. Выбрать переменную, которая...: входит в максимальное число клозов/входить в самый короткий клоз.
б. Какое значение придавать переменной.
Привет от Серёжи

# Алгоритм CDCL (conflict-driven clause learning):
Основан на DPLL.
DPLL - это хронологический backtracking, он откатывает только значение последней переменной.
А CDCL может делать вывод "мы ошиблись со значением переменных несколько выборов назад" и откатиться сразу на несколько шагов назад. А ещё он может запоминать, что какие-то комбинации переменных пробовать не надо.

Идея примерно такая: когда мы получили противоречие (т.е. пустой клоз), то мы смотрим, какие значения переменных привели к обнулению этого клозо. Некоторой структурой данных (implication graph) мы выясняем, из какого условно-минимального набора присваиваний этот клоз обнуляется. Это какая-то конъюнкция условий. Берём отрицание - получаем дизъюнкцию и мы знаем, что она должна быть верна. Просто добавили в исходную формулу. Теперь алгоритм будет очень быстро отсекаться --- это и есть clause learning, переиспользуем в следующих ветках.

Некоторые SAT-солверы делают так: запускают CDCL, обрубают через некоторое время, но выученные клозы запоминают.

# Унификация
Переползаем в область "исчисления первого порядка".
По сравнению с пропозициональной логикой у нас появляются: предметные переменные и функциональные значки, предикатные значки, кванторы по предметным переменным. Было в первом семестре.

Лирическое отступление: а логика второго порядка --- это когда мы можем делать кванторы по функциональным значкам.

Чтобы проинтерпретировать формулу, надо выбрать область интерпретации (множество, откуда берутся значения предметных переменных), проинтерпретировать функциональные значки (выбрать всюду определённые функции) и предикатные значки (выбрать всюду определённые предикаты).
Обозначается:
[[ \forall x . P(x) ]]_I, где I - это интерпретация. I=(D, F, P) --- домен, смысл функциональных, смысл предикатных.

Формулы бывают замкнутые и незамкнутые. Замкнутые всегда либо истины, либо ложны (в зависимости от интерпретации).

Интерпретация замкнутой формулы, при которой она true, называется "моделью".

Выполнимость замкнутой формулы <=> существование модели.

Согласованность интерпретаций: I_1 согласовано с I_2, если есть отображение f: D_1 \to D_2 такое, что значение любого предиката сохраняется при применении f.

Есть term model (Herbrand interpretation): домен "--- это множество термов (константы -- нульарные функции и функциональные значки). Очевидно, что для любой интерпретации I можно подобрать такую интерпретацию значков, что получившаяся интерпретация будет согласована с I.

Обобщение SAT: давайте искать модель для пропозициональной формулы. Из-за Herbrand interpretation нам достаточно лишь подобрать значения предикатов.

<тут-я-уснул-на-моменте-унификации>

Но когда проснулся, ты мы просто взяли алгоритм унификации (как для типов, просто поддерживаем произвольную арность функциональых символов, а не только бинарную стрелочку)

# Обобщаем SAT-солверы на формулы первого порядка

Раньше в методе резолюций мы искали литерал L и \not L и делали резолюцию.
А теперь давайте искать одинаковые предикаты (с разными знаками) и унифицировать их.
Можно доказать, что от унификации (если она возможна) выполнимость не потеряется.
Можем таким образом получить противоречие.

# Хорновские дизъюнкты
Такой клоз - это дизъюнкция литералов, в которые не более одного положительного.
Или, если переписать (у которого ровно один положительный): (q_1 \land q_2 \land \dots \land q_k \Rightarrow p).

# Вторая группа пар
Пролог-машина
Алгоритм SLD (Selective Linear resolution with Define сlause).

## Пример работы
add(0, Y, Y).
add(s(X), Y, s(Z)) :- add(X, Y, Z).
? add(s(0), s(0), T) # Goal

Второе получается хорновским клозом: add(s(X), Y, s(z)) \lor \lnot(add(X, Y, Z)).

У нас есть два хорновских клоза, надо вывести goal. Взяли отрицание goal, добавили его как клоз, ищем опровержение методом резолюций.
Алгоритм: взяли левый терм из goal, резолюция с кем-нибудь.

## Другой пример
add(0, Y, Y).
add(s(X), Y, s(Z)) :- add(X, Y, Z).
? add(s(0), R, s(s(0))

Сначала сделали резолюцию со вторым правилом: [X -> 0, Y -> R, Z -> s(0)].
Получили add(0, R, s(0)).
Сматчили, теперь только первое правило (в нём уже новый набор переменных): [X -> 0, Y -> R, Z -> s(0), Y2 -> R, R -> s(0)].
Ответ: R = s(0).

## Третий пример
add(0, Y, Y).
add(s(X), Y, s(Z)) :- add(X, Y, Z).
? add(s(s(0)), R, s(0)

Делаем резолюцию со вторым: [X -> s(0), Y -> R, Z -> 0].
Получили add(s(0), R, 0).
И вот теперь не смогли сделать никаких резолюций.

## Недетерминированный пример
add(s(X), Y, Z) :- add(X, Y, Z).
add(0, Y, Y)
? add(R, s(0), s(s(0))).

Сделали резолюцию с первым: [R -> s(X1), Y1 -> s(0), Z1 -> s(0)].
add(X1, Y1, Z1) ---> add(x1, s(0), s(0)).
- Сделали с первым (хотя надо бы со вторым): [X1 -> s(X2), Y2 -> s(0), Z2 -> 0].
  add(X2, Y2, Z2) ---> add(X2, s(0), 0).
  А теперь не получилось ни с чем сделать. Backtracking.
- Делаем вместо этого со вторым: [X1 -> 0, Y2 -> s(0)].
  add(0, Y2, Y2) --> {}
  Ура, получилось нужное "ничего". Пишем исходное решение: R -> s(X1) -> s(0).
