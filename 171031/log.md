# Disequality constraints
## Лирическое отступление
Важная штука: она есть в MiniKanren, но её нет в Прологе (там только ограниченное).
Да и вообще разрешение ограничений (constraints) может быть важнее самого логического программирования.
Строго говоря, disequality constraint не увеличивает выразительную сложность языка (как был Тьюринг-полный, так и остался).

## Пример
В MiniKanren disequality constraint (будем называть "дезунификация")
вводится на том же уровне, что и унификация, да и выглядит так же.
Реализуется несложно, но там есть тонкости.
Например, давайте напишем поиск в ассоциативном списке (список пар):
```ocaml
let rec lookupo al k v =
    fresh (k' v' t)
	    (al === (k' , v') : t) &&&
		((k' === k &&& v' === v) |||
		 (k' !== k &&& lookupo k t v))
```
Тут нам disequality constraint нужен для того, чтобы выдавать только первый элемент
с таким ключом, а не произвольный.
Написали на MiniKanren в OCaml код, попросили поискать сколько-нибудь списков, в которых `a` соответствует `b`.
Запустили, увидели ответы вида: "список, в котором первые x элементов любые (только ключ не равен `a`),
а элемент x+1 имеет вид `(a, b)`".
На самом деле ответ на задачу, в которой разрешены disequality constraint имеет такой вид:
обычный терм, но на некоторые переменные есть дополнительные условия: "она не равна такому-то
терму (в котором тоже могут быть подобные ограничения)".

## Алгоритм
Disequality constraint были мутными и непонятными, пока кто-то не догадался,
что их можно сделать на основе унификации.
Раньше было состояние: (подстановка переменных, номер переменное).
Добавляем туда новую информацию: "пул disequality constraint"
(это множество подстановок, каждая из которых должна _не выполняться_).

После этого меняем код унификации и добавляем новую операцию "disequality constraint".
1. Меняем унификацию так, чтобы она проверяла, что не нарушились старые disequality constraint.
   а. Если унифицировать не получилось, то, как и раньше, возвращаем старые ответ.
   б. Если добавлений к подстановке не произошло, то ничего не поменялось, новой информации нет => ничего не поломалось.
   в. Если добавилась новая информция phi (это подстановка), то с каждым элементом пула надо сделать:
     I. Унифицировать его в подстановке phi. Если не получилось - значит, точно уже никогда не получится, всё ок, выкидываем из пула.
	 II. Получилось без дополнительной инфы - упс, уже всегда нарушим, обрубаемся.
	 III. Получилось с дополнительной инфой - заменяем элемент пула на эту дополнительную инфу.
2. Пишем disequality constraint:
  а. Попытались унифицировать аргументы. Если не получилось, то можно просто ничего не делать.
  б. Если получилось без новой информации, то он гарантированно нарушен, обрубаемся.
  в. Если получилось с новой информацией, добавляем её в состояние.

## Сложности с reify
Например, получили ответ: `x`; в пуле лежит две штуки: `x->y`, `y->x`.
И если начнём просто выводить, получим `x[=/=y[=/=x[=/=y[...]]]]`.

## Прочие disequality
В MiniKanren в Racket/Scheme есть ещё три ограничения:
1. numbero - терм является "числом"
2. symbolo - терм является "символом"
3. absento - один терм не встречается в другом

# Встраивание MiniKanren в OCaml
Ocanren - это первое встраивание типизированного minikanren.
У нас, например, сейчас написано на Haskell нетипизированно (потому что у всех термов одинаковый тип).

Тут был кошмар какой-то.
