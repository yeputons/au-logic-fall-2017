# Datalog

Это язык, разработанный в 90-х годах.
С точки зрения синтаксиса похож на подмножество Prolog.
Его можно рассматривать, как Prolog над конечными доменами
(домен ~ областями определения переменных).

В чём отличие? В Prolog у нас есть функциональные значки,
которые отличаются от предикатов только контекстом
(они не могут стоять на самом верхнем уровне - там предикаты).
А в Datalog у нас функциональные значки все нульарные, то
есть ничего, кроме констант нет => конечные домены.

Предикаты разделяются на два сорта (в теории можно смешивать,
но все считают, что они разные):

* Extensional. Это на самом деле предикаты, встречающиеся в
  командах, которые раньше называлось "фактом".
  Такая команда, у которой нет правой части (справа от `:-`).
  В целом в него можно включать переменные, но это необязательно,
  потому что каждая переменная может принимать лишь конечное
  число значений.
* Intensional. Это предикаты, которые стоят в левой части
  от `:-`. Аналогично, в левой части не должно быть свободных
  переменных.

Алгоритм поиска отличаются от Prolog: мы просто насыщаем
(saturate) факты по правилам, пока что-то новое узнаём.
Так как все предикаты конечноарные, значений конечно,
то это за конечное время выведет всё верное.

И даже можно добавить отрицание. Почти всегда.

# Лирическое отступление: почему отрицание - это плохо

Глобально логическое программирование работает с какими-то
потенциально бесконечными/рекурсивными формулами.
На них не то чтобы можно "взять и вычислить". Как тогда задавать
смысл? Надо делать искать неподвижные точки функций/формулами
(привет от Y-комбинатора). Но они не всегда есть.

Есть один прикольный случай, когда всегда есть (теорема Кнастера-Тарского):
если у нас есть множество X и частичный порядок-решётка <= на нём,
то если какое-нибудь _монотонное_ отображение из X на него самого,
то у него будет неподвижная точка.
А ещё монотонные отображения можно комбинировать, получать монотонное.

На доске была какая-то картинка с X, X^N, X^{X^N} (N-арные функции).
Вроде это всё решётки.

Конъюнкция и дизъюнкция монотонны, а вот отрицание не монотонно.
Поэтому оно всё ломает.
  
# Stratified negation
Это мы позволяем в Datalog добавлять отрицание к предикатам,
но только иногда. Чтобы не образовались циклы p :- ... q ...,
q :- ... !p .... (возможно, транзитивные).
Тогда мы можем взять компонент сильной связности зависимости между
предикатами и обработать их в таком порядке. А внутри компоненты
предикатов нет. Это чем-то хорошо.

Хорошо тем, что можно просто пополнять набор фактов и не париться
про отрицания. А если у нас есть цикл A -> B -> C, !C -> A, то
узнав факт про A, мы пополним только B и C, но вот после этого
правило !C -> A применять не сможем, ведь мы не знаем, какие из
неизвестных фактов C точно неверны, а какие мы просто не вывели.

# Live Variiable Analysis
Пусть есть какой-нибудь простой императивнй язык программирования,
в котором есть скалярные переменные (ссылок-указателей нет),
можно присваивать в них значения, вычисляемые выражениями,
есть `if then goto`, `jmp label`, `stop`. Давайте считать,
что у каждой команды есть метка. Ещё считаем, что все
переменные изначально пронициализированы.

Можно построить консервативный граф достижимости команд:
из какой команды в какую можно перейти (условия `if` не пытаемся
проверить, иначе неразрешимая задача).
Будем писать, что из команды l достижима ~~> команда m.

Определим <<переменная x "жива" в метке l>>: это значит,
что есть команда m, присваивающая в x (m~~>l), есть
команда n, читающая из x (l~~>n), при этом есть хотя бы
один путь l~~>n, на котором нет других записей в "x".
Альтернатива: в "x" в метке l нельзя ничего записать без изменения
семантики программы.

На самом деле условие "была запись раньше" можно выкинуть,
потому что переменная исходно инициализирована, иначе будет сложно.

Давайте запишем это на Datalog.
Будут предикаты `read(x, l)` (факты), `write(x, l)` (факты),
`reach(l, m)` (факты, но транзитивности нет), `live(x, l)` (сейчас запишем).

live(x, l) :- read(x, l).
live(x, l) :-
  % тут неявно стоит квантор существования по всем несвязным переменным (m), как обычно.
  live(x, m), reach(m, l), !write(x, l).
  % тут важно, что reach не транзитивен.

Возможно, было бы проще записать это дело BFS'ом или чем-то таким.
Но зато в виде логического программирования про это дело можно что-то доказывать.
Мы же не так просто делаем анализ, а с целью применить оптимизацию.

# BDD (Binary Decision Diagram)
Это такая структура данных для представления логических формул/структур данных.
Она весьма компактна и может давать выигрыш по памяти/времени (а может и не давать).

Обычно под BDD подразумевают ROBDD (Reduce Ordered BDD).

Основано на представлении Шеннона: пусть есть пропозициональная формула
F(x_1, ..., x_n). Мы можем "разложить" её по переменной x_i:
F(...) = (x_i && F(x_1, ... 1, ..., x_n)) || (!x_i && F(x_1, ... 0, ..., x_n))
Чем оно хорошо: позволяет элиминировать переменную. Например, если x_i был
в большой-большой конъюнкции/дизъюнкции, то что-то может стереться.

Давайте зафиксируем какой-нибудь порядок элиминации переменных.
Элиминировали переменную, получили два поддерева. В каждом тоже элиминировали.
Получили такое длинное дерево высоты "размер переменных", на каждом уровне
во всех ветках деление по какой-то фиксированной переменной. Это просто BDD,
оно ничего не экономит и никому не нужно.

А дальше мы начинаем склеивать уровни снизу вверх: склеили все 0/1 внизу
(очевидно, что в листьях уже нет переменных). На следующем уровне
склеиваем вершины, у которых совпадают упорядоченная пара детей.

Интересный факт: существуют формулы, для которых можно построить ROBDD
быстрее, чем за экспоненту (а ещё это зависит от порядка переменных,
который можно подбирать эвристиками). Но есть формулы, для которых всё плохо
для любого порядка. Практика показывает, правда, что BDD - это хорошо.

Как это использовать в контексте Datalog: любой элемент конечного домена,
можно представлять в виде битового вектора длины n. А предикаты - в виде
функций над булевыми векторами, а их - в виде BDD.
ВНЕЗАПНО оказывается, что несмотря на то, что константы - это какие-то случайные
битовые вектора, то предикаты всё равно в виде BDD хранятся лучше, чем просто
как списки множеств.

Ещё факт: на Haskell это либо задолбаться писать, либо будет тормозить. А вот
писать на императивном C - самое то: и несложно, и будет выигрыш по времени.
