# Гомоморфизмы

Это я пропустил, но тут было что-то с курса по идиомам функционального программирования.
Гетерогенные коллекции и иже с ними.
https://github.com/dboulytchev/uKanren_transformations/blob/master/src/Term.hs

# miniKanren

Игрушечный язык для реляционного программирования.
Язык с неопределённым статусом: Prolog большой, древний, известный, про него все знают и пишут статьи; а вот про miniKanren как-то неоч.

Идея такая: это внешний предметно-ориентированный язык (ориентирован на определённые класс проблем), нахлобучка на другие языки.
Самый известный диалект в промышленности: CoreLogic для Closure.

Мотивация для создания miniKanren: вообще говоря, I/O и прочая
фигня в логических языках не нужны; на них нужно писать только маленькую логику программы.
Поэтому давайте не делать монолитную систему, а сделаем встраиваемый язык.

По сравнению с прологом:
1. Программирование на вашем любимом языке. В рамках этого языка, конечно (нет перегрузки операций/gc --- нам плохо).
2. Язык с полным поиском: найдёт каждое решение, если подождать. До есть не DFS. Но и не BFS --- там хитрее. Interleaving search, кажется, придумал Киселёв(?). Он в начале находит "интересные" термы, а потом "неинтересные".
3. Он гораздо более декларативный. От порядка написания программы зависит меньше.
4. Реляционность --- если есть утверждение вида P(x, y), то можем найти и x -> y, и y -> x (если есть). В прологе зависит от порядка клозов (но это скорее п.3), можно написать необращаемую формулу (x = y + 1, потому что с арифметикой как-то не оч).
5. Не получится оптимизировать программу под конкретную задачу, как на прологе.

## ocanren
Типизированная реализация miniKanren, встроенная в OCaml. Вроде раньше такого никто не делал :)
А, скажем, реализация в Java не слишком типизированная (там есть общий тип).

## Основы
Можно делать Goal'ы:
t_1 = t_2  // Утверждение о том, что можно унифицировать
(t_1 != t_2)  // Утверждение о том, что нельзя унифицировать

Дальше можно делать суперпозиции Goal'ов:
G_1 /\ G_2
G_1 \/ G_2
fresh(x) G  // Введение переменной, квантор существования.

## Пример append
Пример на ocanren (пишется почти так):

let rec append^o x y xy =
  ((x = []) /\ (y = xy)) \/
    (fresh (h t)
	  (x = h :: t) /\
	  fresh (ty)
	    (xy = h :: ty) /\
		(append^o t y ty)
	)
Тип такой: `append : [\alpha] -> [\alpha] -> [\alpha] -> Goal` (каждый список --- считаем, что это терм).
Мы написали goal.
Дальше можно попробовать вычислять всякую фигню:
append [1] q [1; 3]  // Узнаем, что q=[3]
append [1] q [1; r]  // На прологе так нельзя (really?); узнаем, что q=[r]

## Пример вывода типом для STLC
STLC (Standard Typed Lambda Calculus)
https://github.com/dboulytchev/OCanren/blob/master/regression/test005.ml
Вот там записано три правила вывода типов.
Можно выводит тип по терму, а можно и наоборот (реляционный-то). Можно вообще дать кусочек терма, типа, и посмотреть, что получится.

## Пример с арифметикой Пеано
Это просто стандартный пример.

## Реляционный интерпретатор
Можно написать реляционный интерпретатор.
А дальше он будет по программе и входу генерировать выход.
Или по выходу и программе вход.
Или по входам и выходам --- программу.
Или заполнять кусочки в программе.
Или квайн написать, или ещё больший ад.
Пример на простом лямбда-исчислении (там, правда, простые ответы):
https://github.com/dboulytchev/OCanren/blob/master/regression/test006.ml
Охренеть.
https://github.com/webyrd/Barliman

Есть мнение, что miniKanren был специально предназначен для написания релияционных интерпретаторов.
На прологе успех, конечно, год назад сумели повторить, но им пришлось допиливать сам пролог и его поиск (там же dfs).

## Реляционная сортировка
https://github.com/dboulytchev/OCanren/blob/master/samples/sort.ml
Кажется, там написан selection sort.

А потом можно отсортировать список, потом запустить сортировку в обратную сторону и получить все перестановки.

Замечание: miniKanren всё-таки чувствителен к порядку операций.
Поэтому при сортировке выгодно написать две версии, которые работают в разные стороны (одна сортирует, другая от-сортирует), но вот одной очень эффективно не получится.

## Про конвертацию программы
Можно конвертировать функциональные программы в реляционные автоматически.
Пока что это все пишут руками (тот же интерпретатор), но вроде про это
была какая-то работа на конференции (блин, Булычев! А про мой диплом почему так же не получится?).
Более того, можно даже с функциями высшего порядка работать.

## Статья
William A. Byrd, ICFP 2017
A unified approach to solve seven programming problems
