# Практика
Мы делаем shallow embedding языка Minikanren в Haskell.
Без отрицания, правда, оно, типа, сложное.
У нас конструкции ===, &&& и ||| не строят дерево, а потом интерпретируют,
а в каком-то смысле сразу вычисляют.

Интересный факт: если написать add вот так:
add(x + 1, y, z + 1) :- add(x, y, z).
то будет завершаться на x+0=0 после нахождения единственного ответа.

По-хорошему все названия предикатов заканчиваются на 'o' (addo, mulo, appendo).

Кстати, можно попросить сгенерировать список длины три.

# Interleaving search
Сейчас у нас всё написано на мнаде "список", там просто идёт такой DFS.
Он может иногда уйти не в ту ветку и не найти решения. Это некруто.
В прологе, конечно, тоже DFS, но там у нас есть "cut", который может его контролировать.
А в minikanren такого быть не может: он весь такой реляционный.

TODO: Упражение: написать монаду для поиска в ширину.
Чем он плох? Тем, что у нас хоть сколько-нибудь длинные ответы оказываются далеко.

Но в Minikanren используется interleaving search.
Там, на самом деле, много разных вариантов этого самого search.
Самый простой описан в статье про Microkanren (почти не отличается от Minikanren).
Это эвристическая штука, которая хорошо себя показывает на интересных примерах
(а их всего-то ничего - реляционные интерпретаторы).

Определяем теперь монаду с плюсом `Stream a` (раньше это был список).
[Ссылка][1].
Три конструктора: пустой список, список с известным первым элементом, невычисленный список.

[1]: https://github.com/dboulytchev/uKanren_transformations/blob/master/src/Stream.hs

## Важный момент `mplus`
Что делает mplus?
Он переставляет по очереди элементы левого и правого аргумента.
Таким образом, если у нас один из них был бесконечный, мы всё равно сможем обойти оба.
Отсюда прикол: в выражении `mplus a (mplus b c)` у нас на `a` уйдёт половина времени, а на `b` и `c` только четверть.

## Важный момент в `>>=`
Вместо обычного `++` при появлении кучи подцелей мы их не конкатенируем,
а переставляем с бывшим хвостом при помощи `mplus`.

## Зачем нужен Mature/Immature?
Чтобы список у нас был реально ленивым.
Отличие от Haskell в том, что мы тут можем посмотреть на список и понять,
вычислен у него первый элемент или нет, и в зависимости от этого что-то делать.
Называется (в контексте minikanren) inverse-eta-delay.

Так можно защищать goal'ы: вместо `g s` можно писать `\s -> Immature (g s)`.
Нужна редко.
Например, в таком вырожденном примере:
`two x = two x ||| (x === s (s o))`
Тут interleaving search попробует по очереди смотреть налево и направо.
Но чтобы посмотреть налево, надо там найти хотя бы один элемент => бесконечная рекурсия.
Поэтому мы должны это дело защитить при помощи Immature
(встретив его, interleaving search отложит его на следующий раз).

Так как эта штука ничему не мешает, в некоторых реализациях
она просто добавляется к каждому Goal.

TODO: упражнение: почему добавление простого `fresh _` не помогает так же, как добавление Immature?

# Дальнейшие планы
TODO: упражнение: написать interleaving search.

На следующем занятии: disequality constraint.
Говорят, там несложно, но есть техническая работа.
